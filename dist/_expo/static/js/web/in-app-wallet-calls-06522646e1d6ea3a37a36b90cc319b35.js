__d((function(g,_r,i,a,m,e,d){Object.defineProperty(e,"__esModule",{value:!0}),e.inAppWalletGetCallsStatus=async function(n){const{chain:c,client:o,id:l}=n,u=r.get(l);if(!u)throw new Error("Failed to get calls status, unknown bundle id");const h=(0,s.getRpcClient)({chain:c,client:o});let p="success";const f=await Promise.all(u.map((s=>(0,t.eth_getTransactionReceipt)(h,{hash:s}).then((t=>({blockHash:t.blockHash,blockNumber:t.blockNumber,gasUsed:t.gasUsed,logs:t.logs.map((t=>({address:t.address,data:t.data,topics:t.topics}))),status:t.status,transactionHash:t.transactionHash}))).catch((()=>(p="pending",null))))));return{atomic:!1,chainId:c.id,id:l,receipts:f.filter((t=>null!==t)),status:p,statusCode:200,version:"2.0.0"}},e.inAppWalletSendCalls=async function(t){const{account:s,calls:o}=t,u=[],h=(0,l.randomBytesHex)(65);if(r.set(h,u),s.sendBatchTransaction){const t=await(0,c.sendBatchTransaction)({account:s,transactions:o});u.push(t.transactionHash),r.set(h,u)}else for(const t of o){const c=await(0,n.sendAndConfirmTransaction)({account:s,transaction:t});u.push(c.transactionHash),r.set(h,u)}return h};var t=_r(d[0]),s=_r(d[1]),n=_r(d[2]),c=_r(d[3]),o=_r(d[4]),l=_r(d[5]);const r=new o.LruMap(1e3)}),4138,[2763,1668,2894,2904,1131,2401]);