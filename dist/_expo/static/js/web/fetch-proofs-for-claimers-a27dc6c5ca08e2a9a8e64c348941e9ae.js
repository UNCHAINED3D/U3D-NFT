__d((function(g,r,_i,a,m,e,d){Object.defineProperty(e,"__esModule",{value:!0}),e.fetchProofsForClaimer=async function(o){const{contract:l,merkleTreeUri:u,claimer:y}=o,h=o.hashEntry||s.hashEntry,w=await(0,i.download)({client:l.client,uri:u}),f=await w.json(),k=y.slice(2,2+f.shardNybbles).toLowerCase(),D=f.baseUri.endsWith("/")?f.baseUri:`${f.baseUri}/`;let p;try{const t=`${D}${k}.json`,n=await(0,i.download)({client:l.client,uri:t});p=await n.json()}catch{return null}const b=await Promise.all(p.entries.map((async t=>h({chain:l.chain,client:l.client,entry:t,tokenDecimals:o.tokenDecimals})))),P=new n.MerkleTree(b),C=p.entries.find((t=>t.address.toLowerCase()===y.toLowerCase()));if(!C)return null;const E=P.getHexProof(await h({chain:l.chain,client:l.client,entry:C,tokenDecimals:o.tokenDecimals})).concat(p.proofs),_=C.currencyAddress||t.ZERO_ADDRESS,v=await(async()=>{if((0,t.isNativeTokenAddress)(_)||_===t.ZERO_ADDRESS)return 18;const[{getContract:n},{decimals:i}]=await Promise.all([r(d[6])(d[5],d.paths),r(d[6])(d[7],d.paths)]),c=n({address:_,chain:l.chain,client:l.client});return await i({contract:c})})();return{currency:_,pricePerToken:(0,c.convertQuantity)({quantity:C.price||"unlimited",tokenDecimals:v}),proof:E,quantityLimitPerWallet:(0,c.convertQuantity)({quantity:C.maxClaimable||"unlimited",tokenDecimals:o.tokenDecimals})}};var t=r(d[0]),n=r(d[1]),i=r(d[2]),c=r(d[3]),s=r(d[4])}),5268,{"0":1237,"1":5269,"2":2392,"3":5270,"4":5271,"5":1238,"6":1353,"7":2890,"paths":{}});